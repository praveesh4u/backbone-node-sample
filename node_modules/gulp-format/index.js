var os = require('os');
var fs = require('fs');
var path = require('path');
var gutil = require('gulp-util');
var streamEqual = require('stream-equal');
var through = require('through2');
var spawn = require('child_process').spawn;

var VERSION = require('./package.json').version;
var LOCATION = __filename;

var errors = [];
var formatted = [];

function process(args, done, stdio) {
  var nativeBinary =
      __dirname + '/bin/' + os.platform() + "_" + os.arch() + '/clang-format';
  if (os.platform() === 'win32') {
    nativeBinary += '.exe';
  }
  if (!fs.existsSync(nativeBinary)) {
    message =
        "Doesn't bundle the clang-format executable for your platform" + "(" +
        os.platform() + "_" + os.arch() + "). " +
        "Consider installing it with your native package manager instead. " +
        nativeBinary;
    throw new Error(message);
  }
  var clangFormatProcess = spawn(nativeBinary, args, {stdio: stdio});
  clangFormatProcess.on('close', function(exit) {
    if (exit) done(exit);
  });
  return clangFormatProcess;
}

function check(options) {
  options = parseOptions(options);
  return through.obj(
      function(file, enc, done) {
        var actual = file.isStream() ?
                         file.content :
                         fs.createReadStream(file.path, {encoding: enc});
        var expected = process(['-style=' + options, file.path], done,
                               ['ignore', 'pipe', process.stderr])
                           .stdout;
        streamEqual(actual, expected, function(err, equal) {
          if (err) {
            return done(err);
          }
          equal || errors.push(file.path);
          done();
        });
      },
      function(cb) {
        if (errors.length > 0) {
          this.emit('warning', new gutil.PluginError('gulp-format',
                                                     'files not formatted: ' +
                                                         errors.join('; ')));
        }
        cb();
      });
}

function format(options) {
  options = parseOptions(options);
  return through.obj(
      function(file, enc, done) {
        process(['-i', '-style=' + options, file.path], done,
                ['ignore', 'pipe', process.stderr]);
        formatted.push(file.path);
        done();
      },
      function(cb) {
        this.emit('info', new gutil.PluginError(
                              'gulp-format',
                              'formatted files: ' + formatted.join('; ')));
        cb();
      });
}

function parseOptions(options) {
  options = options || {BasedOnStyle: 'Google'};
  return typeof options === 'object' ? JSON.stringify(options) : options;
}

module.exports = format;
module.exports.check = check;
module.exports.version = VERSION;
module.exports.location = LOCATION;
